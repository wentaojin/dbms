/*
Copyright Â© 2020 Marvin

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package tidb

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	"github.com/wentaojin/dbms/model/rule"
	"github.com/wentaojin/dbms/utils/constant"
)

// RowChangedEvent store the ddl and dml event
type RowChangedEvent struct {
	SchemaName string `json:"schemaName"`
	TableName  string `json:"tableName"`
	QueryType  string `json:"queryType"`
	CommitTs   uint64 `json:"commitTS"`

	IsDDL    bool   `json:"isDDL"`
	DdlQuery string `json:"ddlQuery"`

	// The table synchronized by TiCDC needs to have at least one valid index. The definition of a valid index is as follows:
	// 1,	the primary key (PRIMARY KEY) is a valid index.
	// 2,	each column in the unique index (UNIQUE INDEX) is explicitly defined as NOT NULL in the table structure and there are no virtual generated columns (VIRTUAL GENERATED COLUMNS).
	// Data synchronization TiCDC will select a valid index as the Handle Index. The HandleKeyFlag of the columns included in the Handle Index is set to 1.
	ValidUniqColumns []string `json:"validUniqColumns"`

	// Represents all field names, but Kafka information does not carry field offsets, and is not guaranteed to be strictly consistent with the order in which the fields are created in the table structure. Sort by field name
	ColumnNames []string          `json:"columnNames"`
	ColumnType  map[string]string `json:"columnType"`

	NewColumnData map[string]interface{} `json:"newColumnData"`
	// Only when this message is generated by an Update type event, record the name of each column and the data value before Update
	OldColumnData map[string]interface{} `json:"oldColumnData"`
}

func (e *RowChangedEvent) String() string {
	js, _ := json.Marshal(e)
	return string(js)
}

func (e *RowChangedEvent) Delete(
	dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string) (string, []interface{}) {
	var schemaName, tableName string
	schemaName, tableName = e.rewriteSchemaTable(tableRoute)
	columnRouteR := e.rewriteTableColumn(columnRoute)

	oldColumnData := make(map[string]interface{})
	for c, p := range e.OldColumnData {
		if val, ok := columnRouteR[c]; ok {
			oldColumnData[val] = p
		} else {
			switch caseFieldRuleT {
			case constant.ParamValueRuleCaseFieldNameUpper:
				oldColumnData[strings.ToUpper(c)] = p
			case constant.ParamValueRuleCaseFieldNameLower:
				oldColumnData[strings.ToLower(c)] = p
			default:
				oldColumnData[c] = p
			}
		}
	}
	switch strings.ToUpper(dbTypeT) {
	case constant.DatabaseTypeOracle:
		delPrefix := fmt.Sprintf(`DELETE FROM "%s"."%s" WHERE`, schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		for c, p := range oldColumnData {
			cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
			params = append(params, p)
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params
	case constant.DatabaseTypePostgresql:
		delPrefix := fmt.Sprintf(`DELETE FROM "%s"."%s" WHERE`, schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		placeholder := 1
		for c, p := range oldColumnData {
			cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
			params = append(params, p)
			placeholder++
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params
	case constant.DatabaseTypeMySQL, constant.DatabaseTypeTiDB:
		delPrefix := fmt.Sprintf("DELETE FROM `%s`.`%s` WHERE", schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		for c, p := range oldColumnData {
			cols = append(cols, fmt.Sprintf("%s = ?", c))
			params = append(params, p)
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params
	default:
		panic(fmt.Errorf("delete statament not support database type [%s]", dbTypeT))
	}

}

func (e *RowChangedEvent) Replace(dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string) (string, []interface{}) {
	var (
		schemaName, tableName string
		validUniqColumns      []string
	)
	schemaName, tableName = e.rewriteSchemaTable(tableRoute)
	columnRouteR := e.rewriteTableColumn(columnRoute)

	newColumnData := make(map[string]interface{})
	for c, p := range e.NewColumnData {
		if val, ok := columnRouteR[c]; ok {
			newColumnData[val] = p
		} else {
			switch caseFieldRuleT {
			case constant.ParamValueRuleCaseFieldNameUpper:
				newColumnData[strings.ToUpper(c)] = p
			case constant.ParamValueRuleCaseFieldNameLower:
				newColumnData[strings.ToLower(c)] = p
			default:
				newColumnData[c] = p
			}
		}
	}
	for _, p := range e.ValidUniqColumns {
		switch caseFieldRuleT {
		case constant.ParamValueRuleCaseFieldNameUpper:
			validUniqColumns = append(validUniqColumns, strings.ToUpper(p))
		case constant.ParamValueRuleCaseFieldNameLower:
			validUniqColumns = append(validUniqColumns, strings.ToLower(p))
		default:
			validUniqColumns = append(validUniqColumns, p)
		}
	}

	switch strings.ToUpper(dbTypeT) {
	case constant.DatabaseTypeOracle:
		insPrefix := fmt.Sprintf(`MERGE INTO "%s"."%s" t`, schemaName, tableName)
		var (
			dualS         []string
			onS           []string
			inCols        []string
			valS          []string
			setS          []string
			params        []interface{}
			originColumns []string
		)
		for c, p := range newColumnData {
			dualS = append(dualS, fmt.Sprintf(`:%s AS "%s"`, c, c))
			inCols = append(inCols, fmt.Sprintf(`"%s"`, c))
			valS = append(valS, fmt.Sprintf(`s."%s"`, c))
			params = append(params, p)
			originColumns = append(originColumns, c)
		}

		for _, p := range validUniqColumns {
			onS = append(onS, fmt.Sprintf(`t."%s" = s."%s"`, p, p))
		}

		for _, s := range difference(originColumns, validUniqColumns) {
			setS = append(setS, fmt.Sprintf(`t."%s" = s."%s"`, s, s))
		}

		return fmt.Sprintf("%s USING (SELECT %s FROM DUAL) s ON (%s) WHEN MATCHED THEN UPDATE SET %s WHEN NOT MATCHED THEN INSERT (%s) VALUES (%s)",
			insPrefix,
			strings.Join(dualS, constant.StringSeparatorComma),
			strings.Join(onS, constant.StringSeparatorComma),
			strings.Join(setS, constant.StringSeparatorComma),
			strings.Join(inCols, constant.StringSeparatorComma),
			strings.Join(valS, constant.StringSeparatorComma)), params
	case constant.DatabaseTypePostgresql:
		insPrefix := fmt.Sprintf(`INSERT INTO "%s"."%s"`, schemaName, tableName)
		var (
			cols   []string
			pals   []string
			params []interface{}
			onS    []string
			setS   []string
		)
		placeholder := 1
		for c, p := range newColumnData {
			cols = append(cols, fmt.Sprintf(`"%s"`, c))
			pals = append(pals, fmt.Sprintf("$%d", placeholder))
			params = append(params, p)
			setS = append(setS, fmt.Sprintf(`"%s" =  EXCLUDED."%s"`, c, c))
			placeholder++
		}
		for _, p := range validUniqColumns {
			onS = append(onS, fmt.Sprintf(`"%s"`, p))
		}
		return fmt.Sprintf("%s (%s) VALUES (%s) ON CONFLICT (%s) DO UPDATE SET %s",
			insPrefix,
			strings.Join(cols, constant.StringSeparatorComma),
			strings.Join(pals, constant.StringSeparatorComma),
			strings.Join(onS, constant.StringSeparatorComma),
			strings.Join(setS, constant.StringSeparatorComma),
		), params
	case constant.DatabaseTypeMySQL, constant.DatabaseTypeTiDB:
		insPrefix := fmt.Sprintf("REPLACE INTO `%s`.`%s` ", schemaName, tableName)
		var (
			cols   []string
			pals   []string
			params []interface{}
		)
		for c, p := range newColumnData {
			cols = append(cols, fmt.Sprintf("`%s`", c))
			pals = append(pals, "?")
			params = append(params, p)
		}
		return fmt.Sprintf("%s (%s) VALUES (%s)", insPrefix,
			strings.Join(cols, constant.StringSeparatorComma), strings.Join(pals, constant.StringSeparatorComma)), params
	default:
		panic(fmt.Errorf("replace statament not support database type [%s]", dbTypeT))
	}
}

func (e *RowChangedEvent) rewriteSchemaTable(tableRoute []*rule.TableRouteRule) (string, string) {
	for _, t := range tableRoute {
		if e.SchemaName == t.SchemaNameS && e.TableName == t.TableNameS {
			return t.SchemaNameT, t.TableNameT
		}
	}
	return e.SchemaName, e.TableName
}

func (e *RowChangedEvent) rewriteTableColumn(columnRoute []*rule.ColumnRouteRule) map[string]string {
	columnR := make(map[string]string)
	for _, t := range columnRoute {
		if e.SchemaName == t.SchemaNameS && e.TableName == t.TableNameS {
			columnR[t.ColumnNameS] = t.ColumnNameT
		}
	}
	return columnR
}

type DDLChangedEvent struct {
	CommitTs   uint64  `json:"commitTs"`
	SchemaName string  `json:"schemaName"`
	TableName  string  `json:"tableName"`
	DdlQuery   string  `json:"ddlQuery"`
	DdlType    DDLType `json:"ddlType"`
}

func (d *DDLChangedEvent) String() string {
	jsb, _ := json.Marshal(d)
	return string(jsb)
}

// DDLChangedEvents is a slice of DDLChangedEvent and implements the sort.Interface interface.
type DDLChangedEvents []*DDLChangedEvent

func (d DDLChangedEvents) Len() int           { return len(d) }
func (d DDLChangedEvents) Less(i, j int) bool { return d[i].CommitTs < d[j].CommitTs }
func (d DDLChangedEvents) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }

// Add a new DDLChangedEvent and keep the ddls sorted by CommitTs
func (d *DDLChangedEvents) Add(event *DDLChangedEvent) {
	*d = append(*d, event)
	sort.Sort(*d)
}

// EventGroup could store change ddl and dml event message.
type EventGroup struct {
	events []*RowChangedEvent
}

// NewEventsGroup will create new event group.
func NewEventGroup() *EventGroup {
	return &EventGroup{
		events: make([]*RowChangedEvent, 0),
	}
}

// Append will append an event to event groups.
func (g *EventGroup) Append(e *RowChangedEvent) {
	g.events = append(g.events, e)
}

// ResolvedTs will get events whose CommitTs is less than or equal to resolveTs,
// and at the same time remove events whose CommitTs is less than or equal to resolveTs from the original queue
func (g *EventGroup) ResolvedTs(resolveTs uint64) []*RowChangedEvent {
	sort.Slice(g.events, func(i, j int) bool {
		return g.events[i].CommitTs < g.events[j].CommitTs
	})

	i := sort.Search(len(g.events), func(i int) bool {
		return g.events[i].CommitTs > resolveTs
	})

	result := g.events[:i]
	g.events = g.events[i:]
	return result
}

// DDLCommitTs returns all events strictly < ddlCommitTs
func (g *EventGroup) DDLCommitTs(ddlCommitTs uint64) []*RowChangedEvent {
	// Sort the events by CommitTs first
	sort.Slice(g.events, func(i, j int) bool {
		return g.events[i].CommitTs < g.events[j].CommitTs
	})

	// Find the first CommitTs >= resolveTs
	i := sort.Search(len(g.events), func(i int) bool {
		return g.events[i].CommitTs >= ddlCommitTs
	})

	// Return all events where CommitTs < ddlCommitTs and update g.events
	result := g.events[:i]
	g.events = g.events[i:]
	return result
}

// å·®éå½æ°ï¼è¿å a ä¸­æä½ b ä¸­æ²¡æçåç´ 
func difference(a, b []string) []string {
	// åå»ºä¸ä¸ª map æ¥å­å¨ b ä¸­çææåç´ 
	set := make(map[string]struct{})
	for _, item := range b {
		set[item] = struct{}{}
	}

	// éå a å¹¶æ¶éé£äºä¸å¨ b ä¸­çåç´ 
	var diff []string
	for _, item := range a {
		if _, found := set[item]; !found {
			diff = append(diff, item)
		}
	}

	return diff
}
