/*
Copyright Â© 2020 Marvin

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package oceanbase

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	"github.com/wentaojin/dbms/message"
	"github.com/wentaojin/dbms/model/rule"
	"github.com/wentaojin/dbms/utils/constant"
	"github.com/wentaojin/dbms/utils/stringutil"
)

type RowChangedEvent struct {
	SchemaName string `json:"schemaName"`
	TableName  string `json:"tableName"`
	QueryType  string `json:"queryType"`
	CommitTs   uint64 `json:"commitTS"`

	IsDDL    bool   `json:"isDDL"`
	DdlQuery string `json:"ddlQuery"`

	// The table synchronized by oceanbase needs to have at least one valid index. The definition of a valid index is as follows:
	// 1,	the primary key (PRIMARY KEY) is a valid index.
	// 2,	each column in the unique index (UNIQUE INDEX) is explicitly defined as NOT NULL in the table structure and there are no virtual generated columns (VIRTUAL GENERATED COLUMNS).
	ValidUniqColumns map[string]interface{} `json:"validUniqColumns"`

	NewColumnData map[string]interface{} `json:"newColumnData"`
	// Only when this message is generated by an Update type event, record the name of each column and the data value before Update
	OldColumnData map[string]interface{} `json:"oldColumnData"`
}

type columnAttr struct {
	ColumnName        string `json:"columnName"`
	ColumnType        string `json:"columnType"`
	IsGeneratedColumn bool   `json:"isGeneratedColumn"`
}

func (e *RowChangedEvent) String() string {
	js, _ := json.Marshal(e)
	return string(js)
}

func (e *RowChangedEvent) Delete(dbTypeS, dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string) (string, []interface{}, error) {
	switch dbTypeS {
	case constant.DatabaseTypeOceanbaseMYSQL:
		return e.DeleteFromObMySQL(dbTypeT, tableRoute, columnRoute, caseFieldRuleT)
	default:
		return "", nil, fmt.Errorf("the upstream database type [%s] not support, please contact author or reselect", dbTypeS)
	}
}

func (e *RowChangedEvent) Insert(dbTypeS, dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string,
	enableVirCol bool) (string, []interface{}, error) {
	switch dbTypeS {
	case constant.DatabaseTypeOceanbaseMYSQL:
		return e.InsertFromObMySQL(dbTypeT, tableRoute, columnRoute, caseFieldRuleT, enableVirCol)
	default:
		return "", nil, fmt.Errorf("the upstream database type [%s] not support, please contact author or reselect", dbTypeS)
	}
}

func (e *RowChangedEvent) DeleteFromObMySQL(
	dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string) (string, []interface{}, error) {
	var schemaName, tableName string
	schemaName, tableName = e.rewriteSchemaTable(tableRoute)
	switch caseFieldRuleT {
	case constant.ParamValueRuleCaseFieldNameUpper:
		schemaName = strings.ToUpper(schemaName)
		tableName = strings.ToUpper(tableName)
	case constant.ParamValueRuleCaseFieldNameLower:
		schemaName = strings.ToLower(schemaName)
		tableName = strings.ToLower(tableName)
	}
	columnRouteR := e.rewriteTableColumn(columnRoute)

	ups := e.upstream(e.SchemaName, e.TableName, caseFieldRuleT, columnRouteR)
	if ups == nil {
		return "", nil, fmt.Errorf("the schema_name_s [%s] table_name_s [%s] metadata not existed, normally should be existed, please contact author or retry", e.SchemaName, e.TableName)
	}
	dows := e.downstream(schemaName, tableName)
	if dows == nil {
		return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] metadata not existed, normally should be existed, please contact author or retry", schemaName, tableName)
	}

	uniqColumnData := make(map[string]interface{})

	for c, p := range e.ValidUniqColumns {
		if val, ok := columnRouteR[c]; ok {
			uniqColumnData[val] = p
		} else {
			switch caseFieldRuleT {
			case constant.ParamValueRuleCaseFieldNameUpper:
				uniqColumnData[strings.ToUpper(c)] = p
			case constant.ParamValueRuleCaseFieldNameLower:
				uniqColumnData[strings.ToLower(c)] = p
			default:
				uniqColumnData[c] = p
			}
		}
	}

	// all downstream databases except MySQL and TiDB use the unified adaptive field length to automatically fill spaces in DELETE statements of char type to avoid data processing errors due to missing spaces (for example, Oracle database queries or DML operations do not automatically fill spaces), while INSERT statements use the original value of the upstream TiDB char data type to consume synchronously.
	switch strings.ToUpper(dbTypeT) {
	case constant.DatabaseTypeOracle:
		delPrefix := fmt.Sprintf(`DELETE FROM "%s"."%s" WHERE`, schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		for c, p := range uniqColumnData {
			if ds, ok := dows.tableColumns[c]; ok {
				if columS, ok := ups.tableColumns[c]; ok {
					tys := columS.columnType
					if p != nil {
						switch {
						case stringutil.IsContainedStringIgnoreCase(
							message.MYSQLCompatibleMsgColumnStringCharacterDatatype, tys) && stringutil.IsContainedStringIgnoreCase(
							constant.OracleCompatibleDatabaseTableColumnBinaryDatatype, ds.columnType):
							cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
							params = append(params, []byte(p.(string)))
							continue
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnDatetimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								cols = append(cols, fmt.Sprintf("%s = TO_DATE(:%s,'YYYY-MM-DD HH24:MI:SS')", c, c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								cols = append(cols, fmt.Sprintf("%s = TO_TIMESTAMP(:%s,'YYYY-MM-DD HH24:MI:SS.FF6')", c, c))
								params = append(params, p)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnYearCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								cols = append(cols, fmt.Sprintf("%s = TO_DATE(:%s,'YYYY')", c, c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								cols = append(cols, fmt.Sprintf("%s = TO_TIMESTAMP(:%s,'YYYY')", c, c))
								params = append(params, p)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnTimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								cols = append(cols, fmt.Sprintf("%s = TO_DATE(:%s,'HH24:MI:SS')", c, c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								cols = append(cols, fmt.Sprintf("%s = TO_TIMESTAMP(:%s,'HH24:MI:SS')", c, c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), "INTERVAL DAY") {
								sec, err := stringutil.ConvertTimeToSeconds(p.(string))
								if err != nil {
									return "", nil, err
								}
								cols = append(cols, fmt.Sprintf("%s = NUMTODSINTERVAL(:%s, 'SECOND')", c, c))
								params = append(params, sec)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnCharCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeChar) ||
								strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeCharacter) ||
								strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeNchar) {
								cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
								str := p.(string)
								inter := ds.dataLength - len(str)
								if inter > 0 {
									params = append(params, fmt.Sprintf("%s%s", str, stringutil.PaddingString(inter, " ", " ")))
								} else {
									params = append(params, p)
								}
								continue
							}
						default:
							cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
							params = append(params, p)
							continue
						}
					}
					// nil == NULL values
					cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
					params = append(params, p)
					continue
				}
				cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
				params = append(params, p)
			} else {
				return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] column_name [%s] metadata information not existed, normally should be existed, please contact author or retry", schemaName, tableName, c)
			}
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params, nil
	case constant.DatabaseTypePostgresql:
		delPrefix := fmt.Sprintf(`DELETE FROM "%s"."%s" WHERE`, schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		placeholder := 1
		for c, p := range uniqColumnData {
			if ds, ok := dows.tableColumns[c]; ok {
				if columnS, ok := ups.tableColumns[c]; ok {
					tys := columnS.columnType
					if p != nil {
						switch {
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnStringCharacterDatatype, tys) && stringutil.IsContainedStringIgnoreCase(
							constant.PostgresDatabaseTableColumnBinaryDatatype, ds.columnType):
							cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
							placeholder++
							params = append(params, []byte(p.(string)))
							continue
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnTimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInPostgresDatatypeTimeWithoutTimeZone) {
								cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
								placeholder++
								params = append(params, p)
								continue
							} else if strings.EqualFold(ds.columnType, constant.BuildInPostgresDatatypeInterval) {
								sec, err := stringutil.ConvertTimeToSeconds(p.(string))
								if err != nil {
									return "", nil, err
								}
								cols = append(cols, fmt.Sprintf("%s = MAKE_INTERVAL(secs => $%d)", c, placeholder))
								placeholder++
								params = append(params, sec)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnCharCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInPostgresDatatypeCharacter) {
								cols = append(cols, fmt.Sprintf("%s = :%s", c, c))
								str := p.(string)
								inter := ds.dataLength - len(str)
								if inter > 0 {
									params = append(params, fmt.Sprintf("%s%s", str, stringutil.PaddingString(inter, " ", " ")))
								} else {
									params = append(params, p)
								}
								continue
							}
						default:
							cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
							placeholder++
							params = append(params, p)
							continue
						}
					}
					// nil == NULL values
					cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
					placeholder++
					params = append(params, p)
					continue
				}
				cols = append(cols, fmt.Sprintf("%s = $%d", c, placeholder))
				placeholder++
				params = append(params, p)
			} else {
				return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] column_name [%s] metadata information not existed, normally should be existed, please contact author or retry", schemaName, tableName, c)
			}
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params, nil
	case constant.DatabaseTypeMySQL, constant.DatabaseTypeTiDB:
		delPrefix := fmt.Sprintf("DELETE FROM `%s`.`%s` WHERE", schemaName, tableName)
		var (
			cols   []string
			params []interface{}
		)
		for c, p := range uniqColumnData {
			cols = append(cols, fmt.Sprintf("%s = ?", c))
			params = append(params, p)
		}
		return fmt.Sprintf("%s %s", delPrefix, strings.Join(cols, " AND ")), params, nil
	default:
		panic(fmt.Errorf("delete statament not support database type [%s]", dbTypeT))
	}

}

func (e *RowChangedEvent) InsertFromObMySQL(dbTypeT string,
	tableRoute []*rule.TableRouteRule,
	columnRoute []*rule.ColumnRouteRule,
	caseFieldRuleT string,
	enableVirCol bool) (string, []interface{}, error) {
	var (
		schemaName, tableName string
		// validUniqColumns      []string
	)
	schemaName, tableName = e.rewriteSchemaTable(tableRoute)
	switch caseFieldRuleT {
	case constant.ParamValueRuleCaseFieldNameUpper:
		schemaName = strings.ToUpper(schemaName)
		tableName = strings.ToUpper(tableName)
	case constant.ParamValueRuleCaseFieldNameLower:
		schemaName = strings.ToLower(schemaName)
		tableName = strings.ToLower(tableName)
	}
	columnRouteR := e.rewriteTableColumn(columnRoute)

	ups := e.upstream(e.SchemaName, e.TableName, caseFieldRuleT, columnRouteR)
	if ups == nil {
		return "", nil, fmt.Errorf("the schema_name_s [%s] table_name_s [%s] metadata not existed, normally should be existed, please contact author or retry", e.SchemaName, e.TableName)
	}
	dows := e.downstream(schemaName, tableName)
	if dows == nil {
		return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] metadata not existed, normally should be existed, please contact author or retry", schemaName, tableName)
	}

	newColumnData := make(map[string]interface{})
	for c, p := range e.NewColumnData {
		var colName string
		if val, ok := columnRouteR[c]; ok {
			colName = val
		} else {
			switch caseFieldRuleT {
			case constant.ParamValueRuleCaseFieldNameUpper:
				colName = strings.ToUpper(c)
			case constant.ParamValueRuleCaseFieldNameLower:
				colName = strings.ToLower(c)
			default:
				colName = c
			}
		}

		if meta, existd := ups.tableColumns[colName]; existd {
			if meta.isGeneraed && !enableVirCol {
				continue
			}
		}
		newColumnData[colName] = p
	}

	switch strings.ToUpper(dbTypeT) {
	case constant.DatabaseTypeOracle:
		insPrefix := fmt.Sprintf(`INSERT INTO "%s"."%s" `, schemaName, tableName)
		var (
			cols   []string
			pals   []string
			params []interface{}
		)
		for c, p := range newColumnData {
			cols = append(cols, fmt.Sprintf(`"%s"`, c))
			if ds, ok := dows.tableColumns[c]; ok {
				if columnS, ok := ups.tableColumns[c]; ok {
					tys := columnS.columnType
					if p != nil {
						switch {
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnStringCharacterDatatype, tys) && stringutil.IsContainedStringIgnoreCase(
							constant.OracleCompatibleDatabaseTableColumnBinaryDatatype, ds.columnType):
							pals = append(pals, fmt.Sprintf(":%s", c))
							params = append(params, []byte(p.(string)))
							continue
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnDatetimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								pals = append(pals, fmt.Sprintf("TO_DATE(:%s,'YYYY-MM-DD HH24:MI:SS')", c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								pals = append(pals, fmt.Sprintf("TO_TIMESTAMP(:%s,'YYYY-MM-DD HH24:MI:SS.FF6')", c))
								params = append(params, p)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnYearCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								pals = append(pals, fmt.Sprintf("TO_DATE(:%s,'YYYY')", c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								pals = append(pals, fmt.Sprintf("TO_TIMESTAMP(:%s,'YYYY')", c))
								params = append(params, p)
								continue
							}
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnTimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInOracleDatatypeDate) {
								pals = append(pals, fmt.Sprintf("TO_DATE(:%s,'HH24:MI:SS')", c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), constant.BuildInOracleDatatypeTimestamp) {
								pals = append(pals, fmt.Sprintf("TO_TIMESTAMP(:%s,'HH24:MI:SS')", c))
								params = append(params, p)
								continue
							} else if strings.Contains(strings.ToUpper(ds.columnType), "INTERVAL DAY") {
								sec, err := stringutil.ConvertTimeToSeconds(p.(string))
								if err != nil {
									return "", nil, err
								}
								pals = append(pals, fmt.Sprintf("NUMTODSINTERVAL(:%s, 'SECOND')", c))
								params = append(params, sec)
								continue
							}
						default:
							pals = append(pals, fmt.Sprintf(":%s", c))
							params = append(params, p)
							continue
						}
					}
					// nil == NULL values
					pals = append(pals, fmt.Sprintf(":%s", c))
					params = append(params, p)
					continue
				}
				pals = append(pals, fmt.Sprintf(":%s", c))
				params = append(params, p)
			} else {
				return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] column_name [%s] metadata information not existed, normally should be existed, please contact author or retry", schemaName, tableName, c)
			}
		}
		return fmt.Sprintf("%s (%s) VALUES (%s)", insPrefix,
			strings.Join(cols, constant.StringSeparatorComma), strings.Join(pals, constant.StringSeparatorComma)), params, nil
	case constant.DatabaseTypePostgresql:
		insPrefix := fmt.Sprintf(`INSERT INTO "%s"."%s"`, schemaName, tableName)
		var (
			cols   []string
			pals   []string
			params []interface{}
		)
		placeholder := 1
		for c, p := range newColumnData {
			cols = append(cols, fmt.Sprintf(`"%s"`, c))
			pals = append(pals, fmt.Sprintf("$%d", placeholder))

			placeholder++

			if ds, ok := dows.tableColumns[c]; ok {
				if columnS, ok := ups.tableColumns[c]; ok {
					tys := columnS.columnType
					if p != nil {
						switch {
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnStringCharacterDatatype, tys) && stringutil.IsContainedStringIgnoreCase(
							constant.PostgresDatabaseTableColumnBinaryDatatype, ds.columnType):
							params = append(params, []byte(p.(string)))
							continue
						case stringutil.IsContainedStringIgnoreCase(message.MYSQLCompatibleMsgColumnTimeCharacterDatatype, tys):
							if strings.EqualFold(ds.columnType, constant.BuildInPostgresDatatypeTimeWithoutTimeZone) {
								params = append(params, p)
								continue
							} else if strings.EqualFold(ds.columnType, constant.BuildInPostgresDatatypeInterval) {
								sec, err := stringutil.ConvertTimeToSeconds(p.(string))
								if err != nil {
									return "", nil, err
								}
								params = append(params, fmt.Sprintf("MAKE_INTERVAL(secs => %d)", sec))
								continue
							}
						default:
							params = append(params, p)
							continue
						}
					}
					// nil == NULL values
					params = append(params, p)
					continue
				}
				params = append(params, p)
			} else {
				return "", nil, fmt.Errorf("the schema_name_t [%s] table_name_t [%s] column_name [%s] metadata information not existed, normally should be existed, please contact author or retry", schemaName, tableName, c)
			}
		}
		return fmt.Sprintf("%s (%s) VALUES (%s)", insPrefix,
			strings.Join(cols, constant.StringSeparatorComma), strings.Join(pals, constant.StringSeparatorComma)), params, nil
	case constant.DatabaseTypeMySQL, constant.DatabaseTypeTiDB:
		insPrefix := fmt.Sprintf("INSERT INTO `%s`.`%s` ", schemaName, tableName)
		var (
			cols   []string
			pals   []string
			params []interface{}
		)
		for c, p := range newColumnData {
			cols = append(cols, fmt.Sprintf("`%s`", c))
			pals = append(pals, "?")
			params = append(params, p)
		}
		return fmt.Sprintf("%s (%s) VALUES (%s)", insPrefix,
			strings.Join(cols, constant.StringSeparatorComma), strings.Join(pals, constant.StringSeparatorComma)), params, nil
	default:
		panic(fmt.Errorf("replace statament not support database type [%s]", dbTypeT))
	}
}

func (e *RowChangedEvent) rewriteSchemaTable(tableRoute []*rule.TableRouteRule) (string, string) {
	for _, t := range tableRoute {
		if e.SchemaName == t.SchemaNameS && e.TableName == t.TableNameS {
			return t.SchemaNameT, t.TableNameT
		}
	}
	return e.SchemaName, e.TableName
}

func (e *RowChangedEvent) rewriteTableColumn(columnRoute []*rule.ColumnRouteRule) map[string]string {
	columnR := make(map[string]string)
	for _, t := range columnRoute {
		if e.SchemaName == t.SchemaNameS && e.TableName == t.TableNameS {
			columnR[t.ColumnNameS] = t.ColumnNameT
		}
	}
	return columnR
}

func (e *RowChangedEvent) upstream(schemaName, tableName, caseFieldRuleT string, columnRoutes map[string]string) *metadata {
	metadata, existed := upMetaCache.Get(schemaName, tableName)
	if existed {
		tableCols := make(map[string]*column)
		for k, v := range metadata.tableColumns {
			if val, ok := columnRoutes[k]; ok {
				v.columnName = val
				tableCols[val] = v
			} else {
				switch caseFieldRuleT {
				case constant.ParamValueRuleCaseFieldNameUpper:
					cols := strings.ToUpper(k)
					v.columnName = cols
					tableCols[cols] = v
				case constant.ParamValueRuleCaseFieldNameLower:
					cols := strings.ToLower(k)
					v.columnName = cols
					tableCols[cols] = v
				default:
					tableCols[k] = v
				}
			}
		}
		metadata.tableColumns = tableCols
		return metadata
	}
	return nil
}

func (e *RowChangedEvent) downstream(schemaName, tableName string) *metadata {
	metadata, existed := downMetaCache.Get(schemaName, tableName)
	if existed {
		return metadata
	}
	return nil
}

type DDLChangedEvent struct {
	CommitTs   uint64 `json:"commitTs"`
	SchemaName string `json:"schemaName"`
	TableName  string `json:"tableName"`
	DdlQuery   string `json:"ddlQuery"`
	DdlType    string `json:"ddlType"`
}

func (d *DDLChangedEvent) String() string {
	jsb, _ := json.Marshal(d)
	return string(jsb)
}

// DDLChangedEvents is a slice of DDLChangedEvent and implements the sort.Interface interface.
type DDLChangedEvents []*DDLChangedEvent

func (d DDLChangedEvents) Len() int           { return len(d) }
func (d DDLChangedEvents) Less(i, j int) bool { return d[i].CommitTs < d[j].CommitTs }
func (d DDLChangedEvents) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }

// Add a new DDLChangedEvent and keep the ddls sorted by CommitTs
func (d *DDLChangedEvents) Add(event *DDLChangedEvent) {
	*d = append(*d, event)
	sort.Sort(*d)
}

// EventGroup could store change ddl and dml event message.
type EventGroup struct {
	events []*RowChangedEvent
}

// NewEventGroup will create new event group.
func NewEventGroup() *EventGroup {
	return &EventGroup{
		events: make([]*RowChangedEvent, 0),
	}
}

// Append will append an event to event groups.
func (g *EventGroup) Append(e *RowChangedEvent) {
	g.events = append(g.events, e)
}

// OrderSortedEventCommitTs extract and sort all Commits
func (g *EventGroup) OrderSortedEventCommitTs() []*RowChangedEvent {
	// Sort the events by CommitTs first
	sort.Slice(g.events, func(i, j int) bool {
		return g.events[i].CommitTs < g.events[j].CommitTs
	})
	return g.events
}

// DDLCommitTs returns all events strictly < ddlCommitTs
func (g *EventGroup) DDLCommitTs(ddlCommitTs uint64) []*RowChangedEvent {
	// Sort the events by CommitTs first
	sort.Slice(g.events, func(i, j int) bool {
		return g.events[i].CommitTs < g.events[j].CommitTs
	})

	// Find the first CommitTs >= resolveTs
	i := sort.Search(len(g.events), func(i int) bool {
		return g.events[i].CommitTs >= ddlCommitTs
	})

	// Return all events where CommitTs < ddlCommitTs and update g.events
	result := g.events[:i]
	g.events = g.events[i:]
	return result
}

// RemoveDDLCommitTs remove the ddl event equal to ddlCommit ts
func (g *EventGroup) RemoveDDLCommitTs(ddlCommitTs uint64) {
	var retainedEvents []*RowChangedEvent

	// Iterate through the events and separate them into removed and retained slices
	for _, event := range g.events {
		if event.CommitTs == ddlCommitTs && event.IsDDL {
			continue
		} else {
			retainedEvents = append(retainedEvents, event)
		}
	}

	// Update g.events to contain only retained events
	g.events = retainedEvents
}
